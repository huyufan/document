# 全局锁（FIWRL）  表锁  行锁

## 全局锁是怎么用的？

``` shell
flush tables with read lock
```
### 执行后，整个数据库就处于只读状态了 ，这时其他线程执行以下操作，都会被阻塞：

- 对数据的增删改操作，比如 insert、delete、update等语句；
- 对表结构的更改操作，比如 alter table、drop table 等语句。

### 如果要释放全局锁，则要执行这条命令：
- unlock tables


### 全局锁应用场景是什么？
- 全局锁主要应用于做 全库逻辑备份 ，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。加上全局锁，意味着整个数据库都是只读状态。

### 其他方法
- 有的，如果数据库的引擎支持的事务支持 **可重复读的隔离级别** ，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个  Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。
- 因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。
- 备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction  参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。
- InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。
- 但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。


## 表级锁
### 表锁
### 元数据锁（MDL）
### 意向锁
### AUTO-INC 锁


#### 表锁
``` shell
//表级别的共享锁，也就是读锁；
lock tables student read
//表级别的独占锁，也就是写锁；
lock tables student write
```
##### 需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。
##### 也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放
##### 要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：
``` shell
unlock tables
```

#### 元数据锁(MDL)
##### 我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：
- 对一张表进行 CRUD 操作时，加的是 **MDL读锁**
- 对一张表做结构变更操作的时候，加的是 **MDL写锁**

##### MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。
##### 当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。
##### 反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。
##### MDL 是在事务提交后才会释放，这意味着  事务执行期间，MDL 是一直持有的
##### 那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：
- 首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
- 然后，线程 B 也执行了同样的 select  语句，此时并不会阻塞，因为「读读」并不冲突；
- 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，
- 那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

##### 为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？
- 这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。
- 所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。

#### 意向锁
- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；
- 也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。
- 而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。
- 不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：

``` shell
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select * from  ... lock in share mode;

//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```
##### 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read ）和独占表锁（lock tables ... ）发生冲突。

- 表锁和行锁是满足读读共享、读写互斥、写写互斥的。
- 如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。
- 那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。
- 所以 **意向锁的目的是为了快速判断表里是否有记录被加锁**

## AUTO-INC 锁
### 表里的主键通常都会设置成自增的，这是通过对主键字段声明 **AUTO_INCREMENT** 属性实现的
### 之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 **AUTO-INC 锁** 实现的
### AUTO-INC 锁是特殊的表锁机制，锁 不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放 在插入数据时，会加一个表级别的 AUTO-INC 锁 ，然后为被 AUTO_INCREMENT  修饰的字段赋值递增的值，等插入语句执行完成后，才会把  AUTO-INC 锁释放掉。
### 在插入数据时，会加一个表级别的 AUTO-INC 锁 ，然后为被 AUTO_INCREMENT  修饰的字段赋值递增的值，等插入语句执行完成后，才会把  AUTO-INC 锁释放掉。那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT  修饰的字段的值是连续递增的。
### 但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种 轻量级的锁 来实现自增。一样也是在插入数据的时候，会为被 AUTO_INCREMENT  修饰的字段加上轻量级锁， 然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁

### InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。
- 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
- 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
- 当 innodb_autoinc_lock_mode = 1：
#### 普通 insert 语句，自增锁在申请之后就马上释放；
#### 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

##### 当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配  binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生数据不一致的问题

### 当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题


## 行级锁
- 前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为**锁定读**
``` SHELL
//对读取的记录加共享锁
SELECT ... LOCK IN SHARE MODE;
//对读取的记录加独占锁
SELECT ... for update;
```
- 上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放 ，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。
- 共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。

### 行级锁的类型主要有三类：
- Record Lock，记录锁，也就是仅仅把一条记录锁上；
- Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
- Next-Key Lock 临键锁: Record Lock + Gap Lock  的组合 锁定一个范围 并且锁定记录本身

### Record Lock 记录锁  锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：    
- 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
- 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

### 举个例子，当一个事务执行了下面这条语句：
``` SHELL
BEGIN;
SELECT * FROM TABLES WHERE ID = 1 FOR UPDATE;
```
- 就是对  t_test 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。 当事务执行 commit 后，事务过程中生成的锁都会被释放。


### Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。
- 假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。

### 间隙锁虽然存在  X 型间隙锁和 S 型间隙锁，但是并没有什么区别， 间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的