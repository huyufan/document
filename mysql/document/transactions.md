# 事务 有mysql的引擎实现的

## 原子性
- 一个事务中所有操作 要不全部完成 要不全部不完成

## 一致性
- 事务操作前和操作后，数据满足完整性约束

## 隔离性
- 数据库允许多个并发事务同时对其数据进行读写和修改的能力，可以防止多个事务并发执行时由于交叉执行而导致数据不一样

## 持久性
- 事务处理完后，对数据的修改就是永久的，即使系统故障也不会丢失

### 持久性是通过redo.log(重做日志)来保证的
### 原子性是通过undo.log(回滚日志)来保证的
### 隔离性是通过MVCC(多版本并发控制)或锁机制来保证的
### 一致性是通过持久性+原子性+隔离性


## 并行事务 会出现脏读(dirty read) 不可重复读(non-repeatable read) 幻读（phantom read)
- 脏读  就是一个事务读取了另一个[未提交事务修改过的值]
- 不可重复读 在一个事务内多次读取同一个数据 如果出现前后两个读到的数据不一样 就发生了[不可重复读] 现象 
- 幻读 在一个事务多次查询符合条件的[记录数量] 如果出现前后两个记录数量不一样 就发送了[幻读]

### 4中隔离级别
- 读未提交(read uncommitted) 指一个事务还没有提交时，他做的变更就能被其他事务看到
- 读提交(read committed) 指一个事务提交后,别的事务才能看到
- 可重复读(repeatable read) 值一个事务执行过程中看到的数据 一直跟这个事务启动看到的数据时一样的，INNODB 默认的隔离级别
- 串行化(serializable) 会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发送了读写冲突，后访问的事务必须等前一个事务执行完成，才能继续执行

#### 在读未提交时 会出现 脏读 不可重复读  幻读
#### 读提交 会出现 不可重复读  幻读
#### 可重复读 会出现 幻读

#### 可重复读
- 针对快照读（普通的select语句） 通过mvcc 来解决幻读
- 针对当前读(select for update) 时通过next-key lock(记录锁 + 间隙锁) 解决幻读

#### 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
#### 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
#### \[读提交\] 和 \[可重复读\] 通过Read View 来实现 Read View 理解成一个数据快照 \[读提交\] 隔离级别是在 \[每一个执行前\] 都会重新生成Read View， 而 \[可重复读\] 级别是\[启动事务时\] 生成Read View 整个事务都在用这个

#### 开启事务
##### 第一种 begin/start transaction
##### 第二中 start transaction with consistent snapshot
- 执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机；
- 执行了 start transaction with consistent snapshot  命令，就会马上启动事务。


#### Read View 在mvcc 里如何工作
##### Read View 中的四个字段作用
##### 聚簇索引记录中两个跟事务有关的隐藏列

#### Read View 4个字段
- creator_trx_id 创建该 Read View 的事务的事务Id
- m_ids 创建Read View 时 当前数据库中 活跃且未提交 的事务id 列表
- min_trx_id  创建Read View 时 当前数据库中活跃且未提交的事务中最小事务的事务id
- max_trx_id 创建Read View 时 当前数据库中应该给下一个事务的id 值

##### m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的 事务 id 列表 ，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务
##### min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务 ，也就是 m_ids 的最小值。
##### max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值 ，也就是全局事务中最大的事务 id 值 + 1；

###### 隐藏列 trx_id 和 roll_pointer(undo 日志)
- trx_id，当一个事务对某条聚簇索引记录进行改动时，就会 把该事务的事务 id 记录在 trx_id 隐藏列里
- roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。

###### 快照读 时通过mvcc 方式来解决幻读
###### 当前读（select *** for update） 是通过next-key lock(记录锁 +  间隙锁) 类解决幻读的
 